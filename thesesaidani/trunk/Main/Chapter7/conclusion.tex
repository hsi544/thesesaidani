Les travaux exposés dans ce manuscrit traitent entre autres de la problématique de parallélisation de code de traitement d'images sur le processeur Cell. Les détails de l'architecture particulière du Cell sont étudiés avec ses contraintes de programmation. Une méthodologie de portage de code est proposée aux travers d'un exemple d'implémentation d'un algorithme de traitement d'images bas-niveau. Les outils de programmation haut-niveau de l'architecture sont étudiés et un nouvel outil SKELL BE développé au cours de ces travaux est présenté. Ce manuscrit contient également une comparaison de performances entre architectures parallèles sur le même algorithme de traitement d'images.

\section*{Méthodologie de portage d'application de traitement d'images}
Nous avons porté un algorithme de traitement d'images bas-niveau : le détecteur de points d'intérêts de Harris sur le processeur Cell. Cette étude a permis de développer une méthodologie d'optimisation de code sur l'architecture du Cell. Plusieurs volets de la parallélisation et de l'optimisation ont été abordés. Nous avons mis en évidence, d'une part des techniques d'optimisation relevant du traitement d'images, et d'autre part des techniques plus bas-niveau et applicables à d'autres domaines d'application.\\
L'optimisation de l'utilisation de la mémoire a fait l'objet d'une étude approfondie. L'optimisation de la taille des transferts et de la forme des tuiles  de données sont des exemples de techniques apportant un gain important en performances. La fusion d'opérateurs est également une technique efficace sur le Cell. L'importance du schéma de parallélisation a été démontrée par le biais de différentes implémentations, \emph{data parallel}, \emph{task parallel} ou encore hybrides.\\
Une étude comparative des performances temporelles a été menée. La mesure de métriques de passage à l'échelle a également fait l'objet d'une étude. Au delà de l'expertise acquise en développement et parallélisation de code sur le processeur Cell, l'étude se veut un guide méthodologique pour les concepteurs d'outils de parallélisation et de compilateurs qui sont souvent confrontés à des problèmes de performances du code généré.
\section*{\texttt{SKELL BE} : programmation par squelettes algorithmiques pour le processeur Cell}
J'ai développé les briques de base ainsi que la première version de la couche de communication \textbf{CELL-MPI}. Ces développement ont constitué le point de départ du développement de l'outil de parallélisation pour le processeur Cell \texttt{SKELL BE}, en collaboration avec Joel Falcou, auteur de l'outil QUAFF : un outil similaire dédié aux clusters de machines distribuées. Nous avons participé à la conception de la version du générateur de code pour le Cell. Nous avons été également à l'origine des briques logicielles bas-niveau de communication et de synchronisation utilisées par l'outil de génération de code.\\
\texttt{SKELL BE} apporte une réponse différente par rapport aux outils existants qui n'adressent que le parallélisme de données. En effet, \texttt{SKELL BE} donne le choix de différents schémas de parallélisation grâce à des squelettes de base qui peuvent être composés avec d'autres squelettes pour former un graphe complexe exploitant à la fois le parallélisme de données et de tâches.
\section*{Comparaison avec d'autres architectures parallèles}
En plus d'avoir étudié dans le détail l'architecture du Cell et avoir élaboré une méthodologie d'optimisation sur le processeur Cell à travers un exemple d'algorithme de traitement d'images bas-niveau, nous avons étudié les autres architectures parallèles émergente, concurrentes du Cell. Dans cette étude, nous avons mis en avant plusieurs aspects liés au développement et à l'optimisation d'applications sur les architectures parallèles émergentes. Nous avons comparé les modèles de programmation en terme de difficulté de mise en oeuvre. Les performances temporelles, le passage à l'échelle ainsi que l'efficacité énergétique ont également fait l'objet d'une étude comparative. Le but de cette étude est de guider les développeurs de code de traitement d'images dans le choix d'un couple architecture parallèle/outil de programmation pour la mise en oeuvre d'applications exploitant pleinement le parallélisme offert par ces architectures.
\section*{Perspectives}
La couche logicielle de communication pour le Cell \textbf{CELL-MPI} qui a été finalisée après l'achèvement de mes travaux de thèse, a fait l'objet d'un dépôt APP (Agence pour la Protection des Programmes) à l'Université Paris Sud XI.  \textbf{CELL-MPI} développé dans le cadre de cette thèse à également fait l'objet d'une OMTE (Opération de Maturation Technico-Economique) soutenue par le RTRA (Réseau thématique de recherche avancée) Digiteo.\\
En ce qui concerne le processeur Cell. Malgré un succès fulgurant lors de sa sortie en 2007, notamment dans le milieu académique, l'architecture du Cell n'a pas connu de version ultérieure à celle conçue initialement. La difficulté de programmation y est pour beaucoup et l'arrivée tardive d'OpenCL \nomenclature{OpenCL}{Open Computing Language} pour le Cell à la fin 2009 n'a pas provoqué un engouement nouveau pour le Cell.\\
Les travaux de cette thèse peuvent trouver plusieurs débouchés dans le futur. Les méthodologies d'optimisation de code étudiées peuvent être utilisées pour la conception ou l'amélioration d'un compilateur optimisant. Par exemple, un compilateur qui supporte la norme OpenMP 3.0 et qui à introduit la notion de tâche, peut utiliser les techniques d'optimisation des transferts et de placement des tâches pour la génération de code automatique de code sur le Cell ou une architecture hétérogène à mémoire distribuée similaire.\\
L'outil \texttt{SKELL BE} basé sur les squelettes algorithmique peut facilement être étendu à d'autre types de machines :  les GPUs par exemple. L'approche à base de graphe de processus communicants peut également être utilisée sur des architectures de calcul embarquées. En effet, celles-ci requièrent une réactivité et un comportement prédictible qui se prête bien à une modélisation de l'application sous forme de squelettes. La génération automatique de code peut faciliter le développement d'applications pour ce type d'architectures souvent hétérogènes.
Enfin, dans le cadre du développement d'outils de déploiement de code de plus haut-niveau, à base de description graphique de code (Simulink par exemple), les couches de communication et de génération de code développées, peuvent servir comme interface pour le Cell.
