
Dans ce chapitre nous rentrons dans le vif du sujet, à savoir, la parallélisation de code de traitement d'images pour le processeur Cell. L'algorithme considéré est celui de la détection de points d'intérêts de Harris. Le choix de cet algorithme s'est fait selon plusieurs critères qui sont les suivants:
\begin{itemize}
\item C'est un algorithme de traitement d'images bas niveaux qu'on retrouve dans plusieurs applications plus complexes, comme la reconstructions 3D et le suivi d'objets.
\item Il est composé de blocs de traitement de base qui sont représentatifs des algorithmes bas niveau comme les opérateurs de convolution est les opérateurs point à point.
\item C'est un algorithme qui ne peux pas s'exécuter en temps réel sans optimisations spécifiques.
\end{itemize}
Etant donné les caractéristiques de l'architecture du Cell ainsi que celles de l'algorithme le but est de trouver la meilleure implémentation qui permet d'exploiter au mieux les dispositifs haute performance de l'architecture. Le processeur Cell est un vrai concentré de dispositifs accélerateurs parmi lesquels les unités SPE purement SIMD, les controleurs DMA permettant un parallélisme entre transferts mémoire et tâches de calculs ainsi que la multiplicité des coeurs qui permettent de répartir la charge de calcul de plusieurs manières possible soit sous frome de parallélisme de donnée uniquement, ou alors de parallélisme de tâches ou un mélange des deux.
\section{Algorithme de Harris}
La détection de point d'intéréts de Harris et Stephen \cite{harris_corner} est utilisée dans les systèmes de vision par ordinateur pour l'extraction de connaissance comme la détection de mouvement, correspondance d'images, suivi d'objets, reconstruction 3D et reconnaissance d'objets. Cet algorithme fut proposé pour palier aux manques de l'algorithme de Moravec \cite{moravec} qui était sensible au bruit et pas invariant à la rotation. Un coin peut être définit comme étant l'intersection de deux contours lorsque un point d'intérêt peut être définit comme un point ayant une position bien déterminée qui peut être détecté de manière robuste. Ainsi, le point d'intérêt peut être un coin mais aussi un point isolé d'intensité maximum ou minimum localement, une terminaison de ligne ou un point de courbe où la courbure est localement maximale.

\subsection{Description de l'Algorithmes}
Si l'on considère des zones de l'images de dimensions $u \times v$ (dans notre cas $3 \times 3$ dans une images 2-dimensions en niveaux de gris $I$  qui est décalée de $(x, y)$, l'opérateur de Harris est basé sur l'estimation de l'autocorrélation locale $S$ dont l'équation est la suivante:
\begin{equation}
\label{eq_00}
S(x,y) =\sum\limits_{u}\sum\limits_{v} w(u,v)\left( I(u,v) - I(u-x,v-y) \right)^{2}
\end{equation}
Par l'approximation de $S$ avec une série de Taylor du second ordre la matrice de Harris $M$ est donnée par :
\begin{equation}
\label{eq_01}
M=\sum\limits_{u}\sum\limits_{v}w(u,v)\begin{bmatrix}I_{x}^{2}& I_{x}I_{y}\\I_{x}I_{y}&I_{y}^{2}\end{bmatrix}
\end{equation}
Un point d'intérêt est caractérisé par une large variation de $S$ dans toutes les directions du vecteur $(x,y)$. En analysant les valeurs propres de $M$, cette caractérisation peut être exprimée de la manière suivante. Soit $\lambda_{1}$, $\lambda_{2}$ les valeurs propres de $M$:
\begin{enumerate}
	\item Si $\lambda_{1}$ $\approx 0$ et $\lambda_{2}$ $\approx 0$ alors il n'y a pas de point d'intérêt au pixel $(x,y)$.
	\item Si $\lambda_{1}$ $\approx 0$ and $\lambda_{2}$ a une grande valeur positive alors un contour est retrouvé.
	\item Si $\lambda_{1}$ and $\lambda_{2}$ sont deux grandes valeurs positives distinctes alors un coin est détecté.
\end{enumerate}
Harris et Stephens ont constaté que le calcul des valeurs propres est coûteux car elle requiert le calcul d'une racine carrée, et ont proposé à la place l'algorithme suivant : 

\begin{enumerate}
\item Pour chaque pixel $(x, y)$ de l'image calculer la matrice de corrélation $M$:\\
\begin{equation}
\label{eq_03}
M=\begin{bmatrix} A & C \\ C & B \end{bmatrix}; \mbox{où:} A=\left(\frac{\partial I}{\partial x}\right)^{2}\otimes w, B=\left(\frac{\partial I}{\partial y}\right)^{2}\otimes w, A = \left(\frac{\partial I}{\partial x}\frac{\partial I}{\partial y}\right)\otimes w
\end{equation}

Où	$\otimes$ est l'opérateur de convolution $w$ un noyau Gaussien.\\
\item Construire la carte de coarsité en calculant la mesure de coarsité $C(x, y)$ pour chaque pixel $(x, y)$:\\
\begin{equation}
\label{eq_04}
C(x,y)=det(M)-k(trace(M))^{2}
\end{equation}
\begin{eqnarray*}
det(M)=AB-C^{2}\\
trace(M)=A+B\
\end{eqnarray*}
et $k$ une constante empirique.
\item Seuiller la carte d'intérêts en mettant tous les $C(x, y)$ sous un seuil déterminé $T$ à zero. 
\item Effectuer une suppression de non-maximal pour trouver le maximum local. 
\end{enumerate}
Tous les points non-nuls qui restent dans la carte de coarsité sont des points d'intérêts.
\begin{figure}[!htb]
	\centering
\begin{tabular}{cc}
	\includegraphics[width= 0.5\columnwidth]{Chapter2/figures/house1} & \includegraphics[width= 0.5\columnwidth]{Chapter2/figures/house_harris_map}
	\end{tabular}
	\caption{Illustration de la détection de points d'intérêts sur une image niveaux de gris 512$\times$512}
	\label{fig_house}
\end{figure}

\subsection{Détails de l'Implémentation}
\begin{figure}[!htb]
	\centering
	\includegraphics[width= \columnwidth]{Chapter2/figures/harris_NB}
	\caption{Implémentation de l'algorithme de Harris sous forme de graphe flot de données}
	\label{fig_HarrisAlgorithm}
\end{figure}
Une illustration d'une image d'entrée 512$\times$512 en niveau de gris et de la détection de points d'intérêts est donnée dans la figure  \ref{fig_house}. Les images en niveaux de gris sont typiquement des données 8-bit non signées et la sortie de l'algorithme est dans ce cas là un entier 32-bit signé. Toutefois, à cause du nombre limité des instructions dans le jeu du SPU, nous avons choisi d'implémenter l'algorithme en flottant simple-précision et ce pour les entrée, sortie est calculs intermédiaires. Dans notre implémentation nous avons réparti l'algorithme en 4 noyaux de calcul distincts : Un opérateur de Sobel représentant la dérivée dans les directions horrizontale et verticale, un opérateur de multiplication, un opérateur de lissage de Gauss ($w$ dans Eq. \ref{eq_01}) suivi d'un opérateur de coarsité. Dans notre implémentation la constante $k$ dans Eq. \ref{eq_04} est mise à zéro (typiquement elle est fixée à 0.04) car nous avons constaté que le terme en $k$ pouvait être négligé et n'avait pas d'influence sur le résultat. Le graphe flot de données est illustré dans Fig. \ref{fig_HarrisAlgorithm} qui est représentatif des algorithmes de traitement d'images car il contient des noyaux de convolution et des opérateurs point à point. Les noyaux de convolution de Sobel $Grad X$, $Grad Y$ et le  noyaux de lissage $Gauss$ sont définis par :
\begin{eqnarray*}
Grad X = \begin{bmatrix}-1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}; Grad Y = \begin{bmatrix}-1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix}; Gauss = \frac{1}{16}\begin{bmatrix}1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1 \end{bmatrix}
\end{eqnarray*}
%\begin{figure}[!htb]
%	\centering
%	\includegraphics[scale = 0.25]{Chapter2/figures/fig_convo}
%	\caption{Illustration of memory complexity for a $3\times3$ convolution kernel, output/input access ratio is 1/9}
%	\label{fig_convo}
%\end{figure}

%The convolution kernels computation consist in centering the kernel on a pixel and computing the cumulated sum of the point to point product of the kernel elements with the image patch surrounding the central pixel. Hence, the Harris algorithm can be considered as a memory bounded problem since this kind of operators are great bandwidth consumers as they consume more elements than they produce (Fig. \ref{fig_convo}). For this reason we chose to perform memory access optimizations at several levels of the Cell processor memory hierarchy.




